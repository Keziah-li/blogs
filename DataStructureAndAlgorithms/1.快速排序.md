# 快速排序 (Quick Sort)

快速排序是一种高效的排序算法，其基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

## Java 实现

```java
public class QuickSort {

    // 快速排序的主方法，递归地对数组进行排序
    public static void quickSort(int[] array, int low, int high) {
        if (low < high) { // 如果低索引小于高索引，继续排序
            int pivotIndex = partition(array, low, high); // 获取分区点
            quickSort(array, low, pivotIndex - 1); // 对左半部分进行排序
            quickSort(array, pivotIndex + 1, high); // 对右半部分进行排序
        }
    }

    // 分区方法，选择一个枢轴元素，并将数组分成两部分
    private static int partition(int[] array, int low, int high) {
        int pivot = array[high]; // 选择最右边的元素作为枢轴
        int i = low - 1; // 初始化较小元素的索引
        for (int j = low; j < high; j++) { // 遍历数组
            if (array[j] <= pivot) { // 如果当前元素小于或等于枢轴
                i++; // 增加较小元素的索引
                swap(array, i, j); // 交换元素
            }
        }
        swap(array, i + 1, high); // 将枢轴元素放到正确的位置
        return i + 1; // 返回枢轴的索引
    }

    // 交换数组中的两个元素
    private static void swap(int[] array, int i, int j) {
        int temp = array[i]; // 暂存第一个元素
        array[i] = array[j]; // 将第二个元素赋值给第一个元素
        array[j] = temp; // 将暂存的第一个元素赋值给第二个元素
    }

    // 程序的入口，用于测试快速排序算法
    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5}; // 初始化数组
        int n = array.length; // 获取数组长度
        quickSort(array, 0, n - 1); // 调用快速排序方法
        System.out.println("Sorted array: "); // 输出排序后的数组
        for (int num : array) { // 遍历数组
            System.out.print(num + " "); // 打印每个元素
        }
    }
}
```

## 说明

1. **quickSort 方法**: 这是快速排序的主方法，它递归地对数组进行排序。
2. **partition 方法**: 这个方法选择一个枢轴元素，并将数组分成两部分，一部分小于枢轴，另一部分大于枢轴。
3. **swap 方法**: 这个方法用于交换数组中的两个元素。
4. **main 方法**: 这是程序的入口，用于测试快速排序算法。

运行上述代码将输出排序后的数组。
## LeetCode 相关题目

### 简单题

#### 题目: [Sort an Array](https://leetcode.com/problems/sort-an-array/)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1); // 调用快速排序方法
        return nums; // 返回排序后的数组
    }

    private void quickSort(int[] array, int low, int high) {
        if (low < high) { // 如果低索引小于高索引，继续排序
            int pivotIndex = partition(array, low, high); // 获取分区点
            quickSort(array, low, pivotIndex - 1); // 对左半部分进行排序
            quickSort(array, pivotIndex + 1, high); // 对右半部分进行排序
        }
    }

    private int partition(int[] array, int low, int high) {
        int pivot = array[high]; // 选择最右边的元素作为枢轴
        int i = low - 1; // 初始化较小元素的索引
        for (int j = low; j < high; j++) { // 遍历数组
            if (array[j] <= pivot) { // 如果当前元素小于或等于枢轴
                i++; // 增加较小元素的索引
                swap(array, i, j); // 交换元素
            }
        }
        swap(array, i + 1, high); // 将枢轴元素放到正确的位置
        return i + 1; // 返回枢轴的索引
    }

    private void swap(int[] array, int i, int j) {
        int temp = array[i]; // 暂存第一个元素
        array[i] = array[j]; // 将第二个元素赋值给第一个元素
        array[j] = temp; // 将暂存的第一个元素赋值给第二个元素
    }
}
```

### 中等题

#### 题目: [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length - 1, nums.length - k); // 调用快速选择方法
    }

    private int quickSelect(int[] array, int low, int high, int k) {
        if (low == high) { // 如果低索引等于高索引，返回该元素
            return array[low];
        }
        int pivotIndex = partition(array, low, high); // 获取分区点
        if (k == pivotIndex) { // 如果 k 等于分区点，返回该元素
            return array[k];
        } else if (k < pivotIndex) { // 如果 k 小于分区点，在左半部分继续查找
            return quickSelect(array, low, pivotIndex - 1, k);
        } else { // 如果 k 大于分区点，在右半部分继续查找
            return quickSelect(array, pivotIndex + 1, high, k);
        }
    }

    private int partition(int[] array, int low, int high) {
        int pivot = array[high]; // 选择最右边的元素作为枢轴
        int i = low - 1; // 初始化较小元素的索引
        for (int j = low; j < high; j++) { // 遍历数组
            if (array[j] <= pivot) { // 如果当前元素小于或等于枢轴
                i++; // 增加较小元素的索引
                swap(array, i, j); // 交换元素
            }
        }
        swap(array, i + 1, high); // 将枢轴元素放到正确的位置
        return i + 1; // 返回枢轴的索引
    }

    private void swap(int[] array, int i, int j) {
        int temp = array[i]; // 暂存第一个元素
        array[i] = array[j]; // 将第二个元素赋值给第一个元素
        array[j] = temp; // 将暂存的第一个元素赋值给第二个元素
    }
}
```

### 复杂题

#### 题目: [Largest Number](https://leetcode.com/problems/largest-number/)

```java
class Solution {
    public String largestNumber(int[] nums) {
        String[] strs = new String[nums.length]; // 初始化字符串数组
        for (int i = 0; i < nums.length; i++) { // 遍历整数数组
            strs[i] = String.valueOf(nums[i]); // 将整数转换为字符串
        }
        Arrays.sort(strs, (a, b) -> (b + a).compareTo(a + b)); // 按自定义规则排序
        if (strs[0].equals("0")) { // 如果排序后第一个元素是 "0"，返回 "0"
            return "0";
        }
        StringBuilder sb = new StringBuilder(); // 初始化字符串构建器
        for (String str : strs) { // 遍历排序后的字符串数组
            sb.append(str); // 追加到字符串构建器
        }
        return sb.toString(); // 返回结果字符串
    }
}
```

## 时间复杂度和空间复杂度

### 快速排序

- **时间复杂度**: 平均时间复杂度为 O(n log n)，最坏情况下为 O(n^2)。平均情况下，每次分区将数组分成大致相等的两部分，因此递归深度为 log n，每层的操作为 O(n)，所以总时间复杂度为 O(n log n)。最坏情况下，每次分区只减少一个元素，递归深度为 n，总时间复杂度为 O(n^2)。
- **空间复杂度**: 平均空间复杂度为 O(log n)，最坏情况下为 O(n)。递归调用栈的深度决定了空间复杂度，平均情况下递归深度为 log n，最坏情况下递归深度为 n。

### 快速选择

- **时间复杂度**: 平均时间复杂度为 O(n)，最坏情况下为 O(n^2)。与快速排序类似，平均情况下每次分区将数组分成大致相等的两部分，因此递归深度为 log n，每层的操作为 O(n)，所以总时间复杂度为 O(n)。最坏情况下，每次分区只减少一个元素，递归深度为 n，总时间复杂度为 O(n^2)。
- **空间复杂度**: 平均空间复杂度为 O(log n)，最坏情况下为 O(n)。递归调用栈的深度决定了空间复杂度，平均情况下递归深度为 log n，最坏情况下递归深度为 n。